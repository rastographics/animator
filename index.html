<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snap-to-Loop â€” Camera Slideshow</title>
  <link rel="preconnect" href="https://unpkg.com">
  <!-- Tailwind (optional, for quick clean UI) -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- GIF encoder (tiny, battle-tested) -->
  <script src="https://unpkg.com/gif.js@0.2.0/dist/gif.js"></script>
  <style>
    /* prevent iOS pull-to-refresh jank in full-height sections */
    html, body { height: 100%; background: #0b1020; }
    .glass { background: rgba(255,255,255,0.06); backdrop-filter: blur(8px); }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.35rem;
      padding: 0.5rem 1.25rem;
      border-radius: 0.9rem;
      font-weight: 500;
      border: 1px solid rgba(255,255,255,0.25);
      color: #fff;
      background: rgba(255,255,255,0.02);
      transition: border-color 0.2s ease, background-color 0.2s ease,
                  transform 0.15s ease, box-shadow 0.2s ease;
      cursor: pointer;
      text-align: center;
    }
    .btn:hover {
      border-color: rgba(255,255,255,0.45);
      background: rgba(255,255,255,0.08);
    }
    .btn:focus-visible {
      outline: 2px solid rgba(255,255,255,0.6);
      outline-offset: 2px;
    }
    .btn:active { transform: scale(0.98); }
    .btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
      box-shadow: none;
    }
    .btn-primary {
      background: linear-gradient(135deg,#ffffff,#dfe9ff);
      color: #0b1020;
      border-color: transparent;
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
    }
    .btn-primary:hover {
      background: #f4f6ff;
      box-shadow: 0 12px 28px rgba(0,0,0,0.4);
    }
    .btn-ghost {
      background: transparent;
      color: rgba(255,255,255,0.9);
    }
    .btn-ghost:hover {
      background: rgba(255,255,255,0.08);
    }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.75rem;
      padding: 0.2rem 0.65rem;
      border-radius: 0.45rem;
      background: rgba(255,255,255,0.08);
      text-transform: none;
      border: 1px solid rgba(255,255,255,0.15);
      color: rgba(255,255,255,0.85);
    }
    .thumb { aspect-ratio: 1/1; object-fit: cover; }
    video, canvas { border-radius: 1rem; } 
  </style>
</head>
<body class="text-white">
  <main class="max-w-5xl mx-auto p-4 md:p-6 space-y-6">
    <header class="flex items-center justify-between">
      <h1 class="text-xl md:text-2xl font-semibold">ðŸ“¸ Snap-to-Loop</h1>
      <div class="flex items-center gap-2">
        <span id="frameCount" class="badge">0 frames</span>
        <span id="status" class="badge">idle</span>
      </div>
    </header>

    <!-- Camera + capture -->
    <section class="grid md:grid-cols-2 gap-6">
      <div class="glass rounded-2xl p-4 space-y-4">
        <div class="flex items-start justify-between flex-wrap gap-3">
          <div>
            <h2 class="text-lg font-medium">Live Camera</h2>
            <p class="text-sm text-white/70">Tap the preview to capture frames.</p>
          </div>
          <button id="btnFlip" class="btn btn-ghost" title="Flip camera">Flip</button>
        </div>
        <div id="camTap" class="relative rounded-2xl overflow-hidden group cursor-pointer focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/70" role="button" tabindex="0" aria-label="Tap the live camera view to snap a photo">
          <video id="cam" playsinline autoplay muted class="w-full bg-black aspect-[3/4] md:aspect-video pointer-events-none select-none"></video>
          <div id="camHint" class="absolute bottom-4 left-1/2 -translate-x-1/2 px-4 py-2 bg-black/60 rounded-full text-xs font-medium tracking-wide flex items-center gap-2 pointer-events-none transition-all group-hover:bg-black/70">
            <span aria-hidden="true">ðŸ“¸</span>
            <span>Tap anywhere to snap</span>
          </div>
        </div>
      </div>

      <div class="glass rounded-2xl p-4 space-y-4">
        <div class="flex items-start justify-between flex-wrap gap-2">
          <div>
            <h2 class="text-lg font-medium">Preview / Slideshow</h2>
            <p id="slideshowHint" class="text-sm text-white/70">Tap preview to pause</p>
          </div>
          <button id="btnClear" class="btn btn-ghost">Clear</button>
        </div>
        <div id="slideshowTap" class="relative rounded-2xl overflow-hidden focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-white/70 cursor-pointer" role="button" tabindex="0" aria-label="Tap slideshow preview to pause or resume">
          <canvas id="stage" class="w-full h-auto bg-black pointer-events-none"></canvas>
        </div>
        <div class="space-y-2">
          <div class="flex items-center justify-between text-sm text-white/80">
            <span class="font-medium">Speed</span>
            <span id="speedValue" class="text-xs text-white/60">500 ms</span>
          </div>
          <input id="speedControl" type="range" min="100" max="500" step="50" value="500"
                 class="w-full accent-white cursor-pointer">
          <p class="text-xs text-white/60">Drag left for faster loops, right for slower.</p>
        </div>
        <div id="thumbs" class="grid grid-cols-6 gap-2 max-h-36 overflow-auto"></div>
      </div>
    </section>

    <!-- Export -->
    <section class="glass rounded-2xl p-4 space-y-3">
      <h2 class="text-lg font-medium">Export</h2>
      <div class="grid md:grid-cols-2 gap-4">
        <div class="space-y-2">
          <div class="flex items-center gap-3">
            <label class="text-sm text-white/80">GIF size (px wide)
              <input id="gifWidth" type="number" min="128" step="64" value="640"
                     class="ml-2 w-24 rounded-md bg-white/10 border border-white/20 px-2 py-1">
            </label>
            <label class="text-sm text-white/80">Loops
              <input id="loops" type="number" min="1" step="1" value="1"
                     class="ml-2 w-16 rounded-md bg-white/10 border border-white/20 px-2 py-1">
            </label>
          </div>
          <button id="btnExportGif" class="btn btn-primary w-full">Export GIF</button>
          <p class="text-xs text-white/70">GIF exports are great for quick sharing, but can be large.</p>
        </div>

        <div class="space-y-2">
          <div class="flex items-center gap-3">
            <label class="text-sm text-white/80">FPS
              <input id="fps" type="number" min="1" step="1" value="2"
                     class="ml-2 w-16 rounded-md bg-white/10 border border-white/20 px-2 py-1">
            </label>
            <label class="text-sm text-white/80">Loops
              <input id="loopsVid" type="number" min="1" step="1" value="1"
                     class="ml-2 w-16 rounded-md bg-white/10 border border-white/20 px-2 py-1">
            </label>
          </div>
          <button id="btnExportVideo" class="btn btn-primary w-full">Export Video (WebM/MP4*)</button>
          <p class="text-xs text-white/70">
            *Most browsers export WebM; Safari may export MP4/H.264. Filename will reflect the codec.
          </p>
        </div>
      </div>
      <div id="downloads" class="pt-2 grid md:grid-cols-2 gap-2"></div>
    </section>
  </main>

  <script>
  (() => {
    const state = {
      stream: null,
      facing: 'environment',
      frames: [],          // Array<ImageBitmap> for efficiency
      thumbs: [],          // data URLs for quick thumb rendering
      slideshowTimer: null,
      slideIndex: 0,
      delay: 500,
      stageSize: { w: 1280, h: 720 },
      isPaused: false,
    };

    // Elements
    const el = (id) => document.getElementById(id);
    const cam = el('cam');
    const camTap = el('camTap');
    const camHint = el('camHint');
    const stage = el('stage');
    const ctx = stage.getContext('2d');
    const slideshowTap = el('slideshowTap');
    const slideshowHint = el('slideshowHint');
    const btnFlip = el('btnFlip');
    const btnClear = el('btnClear');
    const btnExportGif = el('btnExportGif');
    const btnExportVideo = el('btnExportVideo');
    const thumbs = el('thumbs');
    const frameCount = el('frameCount');
    const statusBadge = el('status');
    const speedControl = el('speedControl');
    const speedValue = el('speedValue');
    const gifWidth = el('gifWidth');
    const loops = el('loops');
    const fps = el('fps');
    const loopsVid = el('loopsVid');
    const downloads = el('downloads');

    // Utils
    const setStatus = (s) => (statusBadge.textContent = s);
    const updateCount = () => (frameCount.textContent = `${state.frames.length} frame${state.frames.length === 1 ? '' : 's'}`);
    const aspectFit = (srcW, srcH, dstW, dstH) => {
      const srcAR = srcW / srcH, dstAR = dstW / dstH;
      if (srcAR > dstAR) {
        const w = dstW, h = Math.round(dstW / srcAR);
        return { sx: 0, sy: 0, sw: srcW, sh: srcH, dx: 0, dy: Math.round((dstH - h) / 2), dw: w, dh: h };
      } else {
        const h = dstH, w = Math.round(dstH * srcAR);
        return { sx: 0, sy: 0, sw: srcW, sh: srcH, dx: Math.round((dstW - w) / 2), dy: 0, dw: w, dh: h };
      }
    };
    const syncStageDimensions = () => {
      if (!stage) return;
      stage.width = state.stageSize.w;
      stage.height = state.stageSize.h;
      stage.style.aspectRatio = `${state.stageSize.w} / ${state.stageSize.h}`;
      stage.style.width = '100%';
      stage.style.height = 'auto';
    };
    const getSpeedMs = () => {
      if (!speedControl) return 500;
      return Math.max(100, Number(speedControl.value) || 500);
    };
    const updateSpeedLabel = () => {
      const ms = getSpeedMs();
      if (speedValue) speedValue.textContent = `${ms} ms`;
      return ms;
    };
    const updateSlideshowHint = () => {
      if (!slideshowHint || !slideshowTap) return;
      const hasLoop = state.frames.length >= 2;
      const isPlaying = !!state.slideshowTimer;
      slideshowTap.setAttribute('aria-pressed', isPlaying ? 'true' : 'false');
      slideshowTap.setAttribute('aria-disabled', hasLoop ? 'false' : 'true');
      if (!hasLoop) {
        slideshowHint.textContent = 'Add 2+ frames to enable slideshow';
        return;
      }
      slideshowHint.textContent = isPlaying ? 'Tap preview to pause' : 'Paused â€” tap to resume';
    };
    syncStageDimensions();

    // Camera control
    async function startCamera() {
      if (state.stream) {
        state.stream.getTracks().forEach(t => t.stop());
      }
      try {
        setStatus('requesting cameraâ€¦');
        state.stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: state.facing }, width: { ideal: 1280 }, height: { ideal: 720 } },
          audio: false
        });
        cam.srcObject = state.stream;
        await cam.play();

        // Initialize stage size to match the camera aspect (landscape default with letterbox in UI)
        const vW = cam.videoWidth || 1280;
        const vH = cam.videoHeight || 720;
        const maxDim = 1280;
        const scale = Math.min(1, maxDim / Math.max(vW, vH));
        state.stageSize = {
          w: Math.round(vW * scale) || 1280,
          h: Math.round(vH * scale) || 720
        };
        syncStageDimensions();
        setStatus('camera ready');
      } catch (err) {
        console.error(err);
        setStatus('camera error (check permissions/HTTPS)');
        alert('Could not access camera. Ensure you are on HTTPS and granted permission.');
      }
    }

    function flipCamera() {
      state.facing = state.facing === 'environment' ? 'user' : 'environment';
      startCamera();
    }

    // Snap current video frame
    async function snap() {
      if (!cam.videoWidth) return;
      // Draw to a temp canvas sized like the video to avoid scaling artifacts
      const temp = document.createElement('canvas');
      temp.width = cam.videoWidth;
      temp.height = cam.videoHeight;
      const tctx = temp.getContext('2d', { willReadFrequently: false });
      tctx.drawImage(cam, 0, 0);

      // Convert to ImageBitmap for efficient slideshow drawing
      const bmp = await createImageBitmap(temp);
      state.frames.push(bmp);
      if (state.frames.length === 1 && camHint) {
        camHint.classList.add('hidden');
        camHint.setAttribute('aria-hidden', 'true');
      }

      // Thumb for UI
      const fit = document.createElement('canvas');
      fit.width = 160; fit.height = 160;
      const fctx = fit.getContext('2d');
      const fitBox = aspectFit(bmp.width, bmp.height, 160, 160);
      fctx.fillStyle = '#000'; fctx.fillRect(0,0,160,160);
      fctx.drawImage(bmp, fitBox.sx, fitBox.sy, fitBox.sw, fitBox.sh, fitBox.dx, fitBox.dy, fitBox.dw, fitBox.dh);
      const url = fit.toDataURL('image/jpeg', 0.9);
      state.thumbs.push(url);

      renderThumbs();
      updateCount();

      // If first frame, show it. If 2+, (re)start slideshow.
      if (state.frames.length === 1) drawFrame(bmp);
      if (state.frames.length >= 2) startSlideshow();
      updateSlideshowHint();
    }

    function renderThumbs() {
      thumbs.innerHTML = '';
      state.thumbs.forEach((src, i) => {
        const img = document.createElement('img');
        img.src = src;
        img.className = 'thumb w-full rounded-lg border border-white/10';
        img.title = `Frame ${i+1}`;
        thumbs.appendChild(img);
      });
    }

    // Draw a single ImageBitmap to stage (letterboxed)
    function drawFrame(bmp) {
      const { w, h } = state.stageSize;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, w, h);
      const box = aspectFit(bmp.width, bmp.height, w, h);
      ctx.drawImage(bmp, box.sx, box.sy, box.sw, box.sh, box.dx, box.dy, box.dw, box.dh);
    }

    function startSlideshow(keepIndex = false) {
      stopSlideshow(true);
      const delay = updateSpeedLabel();
      state.delay = delay;
      setStatus(`slideshow ${delay}ms`);
      if (!keepIndex) state.slideIndex = 0;
      state.slideshowTimer = setInterval(() => {
        if (state.frames.length === 0) return;
        const bmp = state.frames[state.slideIndex % state.frames.length];
        drawFrame(bmp);
        state.slideIndex++;
      }, delay);
      state.isPaused = false;
      updateSlideshowHint();
    }

    function stopSlideshow(preserveState = false) {
      if (state.slideshowTimer) {
        clearInterval(state.slideshowTimer);
        state.slideshowTimer = null;
      }
      if (!preserveState) state.isPaused = false;
      updateSlideshowHint();
    }

    function clearAll() {
      stopSlideshow();
      state.frames.forEach(b => b.close && b.close());
      state.frames = [];
      state.thumbs = [];
      updateCount();
      renderThumbs();
      ctx.clearRect(0, 0, stage.width, stage.height);
      if (camHint) {
        camHint.classList.remove('hidden');
        camHint.removeAttribute('aria-hidden');
      }
      setStatus('cleared');
      updateSlideshowHint();
    }

    function handleCamTap() {
      if (!state.stream || !state.stream.active) {
        startCamera();
        return;
      }
      snap();
    }

    function handleCamKey(e) {
      if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        handleCamTap();
      }
    }

    function handleSpeedChange() {
      const ms = updateSpeedLabel();
      state.delay = ms;
      if (state.frames.length >= 2 && state.slideshowTimer) {
        startSlideshow(true);
      }
    }

    function toggleSlideshow() {
      if (state.frames.length < 2) return;
      if (state.slideshowTimer) {
        stopSlideshow(true);
        state.isPaused = true;
        setStatus('slideshow paused');
      } else {
        state.isPaused = false;
        startSlideshow(true);
      }
      updateSlideshowHint();
    }

    function handleSlideshowTap() {
      if (state.frames.length < 2) return;
      toggleSlideshow();
    }

    function handleSlideshowKey(e) {
      if (e.key === 'Enter' || e.key === ' ' || e.key === 'Spacebar') {
        e.preventDefault();
        handleSlideshowTap();
      }
    }

    // Export GIF
    async function exportGIF() {
      if (state.frames.length === 0) {
        alert('Snap at least 1 frame first.');
        return;
      }
      const delay = getSpeedMs();
      const repeat = Math.max(1, Number(loops.value) || 1);
      const targetW = Math.max(64, Number(gifWidth.value) || 640);

      // Snapshot frames at export time
      const frames = state.frames.slice();
      const ar = frames[0].width / frames[0].height;
      const targetH = Math.round(targetW / ar);

      setStatus('rendering GIFâ€¦');

      // Prepare a working canvas at export size
      const work = document.createElement('canvas');
      work.width = targetW; work.height = targetH;
      const wctx = work.getContext('2d');

      const gif = new GIF({
        workers: 2,
        quality: 10,         // lower = better quality, bigger file
        workerScript: 'assets/gif.worker.js',
        width: targetW,
        height: targetH
      });

      // Add frames (repeat sequence `repeat` times)
      for (let r = 0; r < repeat; r++) {
        for (const bmp of frames) {
          wctx.fillStyle = '#000'; wctx.fillRect(0, 0, targetW, targetH);
          const box = aspectFit(bmp.width, bmp.height, targetW, targetH);
          wctx.drawImage(bmp, box.sx, box.sy, box.sw, box.sh, box.dx, box.dy, box.dw, box.dh);
          gif.addFrame(wctx, { copy: true, delay });
        }
      }

      gif.on('finished', (blob) => {
        const url = URL.createObjectURL(blob);
        download(url, `slideshow_${Date.now()}.gif`);
        setStatus('GIF ready');
      });

      gif.render();
    }

    // Export Video via MediaRecorder capturing the stage canvas at a controlled FPS
    async function exportVideo() {
      if (state.frames.length === 0) {
        alert('Snap at least 1 frame first.');
        return;
      }
      const frameDelay = getSpeedMs();
      const exportFps = Math.max(1, Number(fps.value) || 2);
      const repeat = Math.max(1, Number(loopsVid.value) || 1);
      const totalFrames = state.frames.length * repeat;

      setStatus('recordingâ€¦');
      // Pause live slideshow while exporting for a deterministic render
      const resume = !!state.slideshowTimer;
      stopSlideshow();

      // Drive the canvas manually at exportFps, while capturing its stream
      const stream = stage.captureStream(exportFps);
      // Try preferred types (Safari may support mp4; most browsers webm)
      const typeCandidates = [
        'video/mp4;codecs=h264',
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      const mimeType = typeCandidates.find(t => MediaRecorder.isTypeSupported(t)) || '';
      const rec = new MediaRecorder(stream, mimeType ? { mimeType } : undefined);

      const chunks = [];
      rec.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };
      const stopped = new Promise(resolve => { rec.onstop = resolve; });
      rec.start();

      // Deterministic playback loop
      let idx = 0;
      const frames = state.frames.slice();
      const drawNext = () => {
        const seqIndex = Math.floor(idx) % frames.length;
        drawFrame(frames[seqIndex]);
        idx++;
      };

      // We want each source photo to last exactly frameDelay ms.
      // With exportFps, we compute how many video frames per photo:
      const framesPerPhoto = Math.max(1, Math.round((frameDelay / 1000) * exportFps));
      const totalVideoFrames = totalFrames * framesPerPhoto;

      // Render loop at exportFps
      let rendered = 0;
      const interval = setInterval(() => {
        if (rendered % framesPerPhoto === 0) {
          // advance to next photo every framesPerPhoto ticks
          const photoAdvance = Math.floor(rendered / framesPerPhoto);
          const photoIndex = photoAdvance % frames.length;
          drawFrame(frames[photoIndex]);
        }
        rendered++;
        if (rendered >= totalVideoFrames) {
          clearInterval(interval);
          rec.stop();
        }
      }, Math.round(1000 / exportFps));

      await stopped;

      const blob = new Blob(chunks, { type: rec.mimeType || 'video/webm' });
      const ext = /mp4/.test(blob.type) ? 'mp4' : 'webm';
      const url = URL.createObjectURL(blob);
      addDownload(url, `slideshow_${Date.now()}.${ext}`, `${blob.type} â€¢ ${(blob.size/1024/1024).toFixed(2)} MB`);

      setStatus('video ready');
      if (resume && state.frames.length >= 2) startSlideshow();
    }

    function download(url, filename) {
      addDownload(url, filename);
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    function addDownload(url, filename, meta='') {
      const card = document.createElement('div');
      card.className = 'glass rounded-xl p-3 flex items-center justify-between';
      const left = document.createElement('div');
      left.innerHTML = `<div class="font-medium">${filename}</div><div class="text-xs text-white/70">${meta}</div>`;
      const right = document.createElement('div');
      const a = document.createElement('a');
      a.href = url; a.download = filename;
      a.className = 'btn btn-primary';
      a.textContent = 'Download';
      right.appendChild(a);
      card.appendChild(left);
      card.appendChild(right);
      downloads.prepend(card);
    }

    // Wire up UI
    btnFlip.addEventListener('click', flipCamera);
    btnClear.addEventListener('click', clearAll);
    if (camTap) {
      camTap.addEventListener('click', handleCamTap);
      camTap.addEventListener('keydown', handleCamKey);
    }
    if (speedControl) speedControl.addEventListener('input', handleSpeedChange);
    if (slideshowTap) {
      slideshowTap.addEventListener('click', handleSlideshowTap);
      slideshowTap.addEventListener('keydown', handleSlideshowKey);
    }

    btnExportGif.addEventListener('click', exportGIF);
    btnExportVideo.addEventListener('click', exportVideo);

    updateSpeedLabel();
    updateSlideshowHint();

    // Autostart camera if permissions previously granted
    (async () => {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const hasCam = devices.some(d => d.kind === 'videoinput');
        if (hasCam) startCamera();
      } catch {}
    })();
  })();
  </script>
</body>
</html>
